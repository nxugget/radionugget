---
title: "Writeup Hack-A-Sat : Linky"
summary: "Writeup du challenge HackASat Linky"
date: "2024-12-20"
thumbnail: "/images/blog/thumbnail/linky.webp"
tags: ["writeup", "radio"]
slug: "linky"
---
Description du challenge : *Years have passed since our satellite was designed, and the Systems Engineers didn't do a great job with the documentation. Partial information was left behind in the user documentation and we don't know what power level we should configure the Telemetry transmitter to ensure we have 10 dB of Eb/No margin over the minimum required for BER (4.4 dB)*.

Le challenge est disponible √† [cette adresse](https://github.com/cromulencellc/hackasat-qualifier-2021/tree/main/linky).

Le but est de compl√©ter un [bilan de liaison](https://fr.wikipedia.org/wiki/Bilan_de_liaison) (**budget link**) afin de terminer une documentation pour aider des ing√©nieurs. 
Un bilan de liaison compte l'entieret√© des **gains** et **pertes** d'un **√©metteur** jusqu'√† un **r√©cepteur** dans un syst√®me de communication. En pratique, on en fait un pour la **liaison montante** et un autre pour la **liaison descendante**. Ce bilan permet ainsi d'√©valuer la performance de son syst√®me.

Lan√ßons le challenge : 
```bash
> docker run --rm -i -e FLAG=pouet linky:challenge
...
Here's the information we have captured

************** Global Parameters *****************
Frequency (Hz): 12100000000.0
Wavelength (m): 0.025
Data Rate (bps): 10000000.0
************* Transmit Parameters ****************
Transmit Line Losses (dB): -1
Transmit Half-power Beamwidth (deg): 26.30
Transmit Antenna Gain (dBi): 16.23
Transmit Pointing Error (deg): 10.00
Transmit Pointing Loss (dB): -1.74
*************** Path Parameters ******************
Path Length (km): 2831
Polarization Loss (dB): -0.5
Atmospheric Loss (dB): -2.1
Ionospheric Loss (dB): -0.1
************** Receive Parameters ****************
Receive Antenna Diameter (m): 5.3
Receive Antenna Efficiency: 0.55
Receive Pointing Error (deg): 0.2
Receive System Noise Temperature (K): 522
Receive Line Loss (antenna to LNA) (dB): -2
Receive Demodulator Implementation Loss (dB): -2
Required Eb/No for BER (dB): 4.4

Calculate and provide the receive antenna gain in dBi:
```
Ok, √ßa fait pas mal d'informations. Premi√®re question, on doit calculer le gain de l'**antenne r√©ceptrice**. 

#  1. Calcul du gain 
Pour calculer le gain, on va utiliser la formule `G = 10log(n4œÄa/Œª^2)` ([lien formule](https://calculator.academy/antenna-gain-calculator-2/)).
- `n` -> l'**efficacit√©** de r√©ception de l'antenne. √áa correspond au rapport entre l‚Äô√©nergie √©lectromagn√©tique capt√©e et l‚Äô√©nergie r√©ellement transmise au r√©cepteur. √áa d√©pend nottament des mat√©riaux utilis√©s pour fabriquer la parabole, son design et d'autres trucs. Dans notre cas, elle nous est donn√©e, elle vaut `0.55`.
- `Œª` -> la **longueur d'onde**. On l'a aussi, elle vaut `0.025m`. 
- `a` -> la surface d'**aperture physique** de la parabole. Alors, √ßa on l'a pas mais on peut le calculer facilement. C'est juste la surface r√©elle qui capte les ondes. On nous donne le diam√®tre de notre parabole donc au final, sa surface physique, c'est juste son aire qui se calcule avec la formule `œÄ*r^2` avec `r` le rayon. 

![Dish schema](/images/blog/writeups/linky/linky1.svg)
On peut √† pr√©sent faire les calculs en `Python` par exemple.
```bash
>>> import np as np
>>> r = 5.3/2 #m
>>> a = np.pi * r**2 #m¬≤
>>> Œª = 0.025 #m
>>> n = 0.55
>>> gain = 10 * np.log10((n * 4 * np.pi * a) / (Œª**2)) # dB
>>> print(gain)
53.873341567400146
```
Entrons cette valeur arrondi pour passer √† l'√©tape suivante : 
```bash
> docker run --rm -i -e FLAG=pouet linky:challenge
...
Calculate and provide the receive antenna gain in dBi: 53.9
Good job.  You get to continue
Receive Antenna Gain (dBi): 54.00
Receive Half-power Beamwidth (deg): 0.33
Receive Pointing Error (deg): 0.2
Receive Pointing Loss (dB): -4.48

Okay, now we know the receive antenna gain.
Calculate and provide the ground terminal G/T (dB/K):
```
Prochaine t√¢che, on doit calculer le [rapport gain sur temp√©rature de bruit](https://en.wikipedia.org/wiki/Antenna_gain-to-noise-temperature) (**G/T**) de la **station de sol**.

#  2. Calcul du G/T (Gain-To-Noise Temperature)
Le **G/T** est une mesure de performance d‚Äôune antenne, exprimant le **gain de l‚Äôantenne** par rapport au **bruit thermique** g√©n√©r√©e par les composants internes d'un syst√®me.
Cette fois-ci, on peut utiliser la formule `G/T = G - 10log(N)` ([lien formule](https://www.rfwireless-world.com/calculators/Antenna-G-T-ratio.html)).
- `G` -> l'**antenna gain**, on l'a calcul√© avant, mais **attention**, on veut le **G/T** de la **station de sol** (ground terminal), pas juste de l'**antenne** donc il faut aussi prendre en compte les pertes de transmission qui nous sont donn√©s `Receive Line Loss (antenna to LNA) (dB): -2`.
- `N` -> le **system noise temperature** nous est donn√© √† `522K`. 
  
On calcule tout √ßa : 
```bash
>>> g = 54
>>> rx_line_loss = -2 #dB
>>> temp = 522 #K
>>> g_t = g + rx_line_loss - 10 * np.log10(temp)
>>> print(g_t)
24.696636537377525
```
Entrons-la valeur pour passer √† la suite :
```bash
> docker run --rm -i -e FLAG=pouet linky:challenge
...
Calculate and provide the ground terminal G/T (dB/K): 24.7

Nicely done.  Let's keep going.
Determine the transmit power (in W) to achieve 10dB of Eb/No margin (above minimum for BER):
```
SUPER ! On peut passer √† la derni√®re √©tape. 

#  3. Calcul du Transit Power
√Ä pr√©sent, on doit calculer la **puissance d'√©mission** (transit power) en `W` pour atteindre une marge de `10dB` de **Eb/No**¬†au-dessus du minimum requis pour le taux d‚Äôerreur binaire (**BER**). 
Pour la calculer, on va se servir la formule de la [PIRE](https://fr.wikipedia.org/wiki/Puissance_isotrope_rayonn%C3%A9e_%C3%A9quivalente) (**P**uissance **I**sotrope **R**ayonn√©e **√â**quivalente) : `PIRE = P - L + G` avec : 
- `PIRE` -> en `dBW` (**EIRP** en anglais). √áa sert globalement √† calculer l'efficacit√© d'un **syst√®me d'√©mission** en prenant en compte la puissance de l'**√©metteur**, l'**antenne**, et la **ligne** qui relie les deux. 
- `P` -> la puissance d'√©mission en `dBW`. (C'est ce que l'on cherche)
- `L` -> les pertes de ligne en `dB`.
- `G` -> le gain de l'antenne **√©mettrice** en `dB`.

Voici un exemple de calcul de **PIRE** : 
![PIRE](/images/blog/writeups/linky/linky4.svg)

Retournons la formule pour isoler la **puissance d'√©mission** : `PIRE = P - L + G <=> P = PIRE + L - G`.
Malheuresement, la **PIRE** ne nous ai pas donn√© mais on peut la calculer avec le [RSSI](https://fr.wikipedia.org/wiki/Received_Signal_Strength_Indicator) qui repr√©sente le niveau de **puissance en r√©ception** d'un signal. Ce dernier est d√©finit par la formule suivante : `RSSI = PIRE - L` avec `L` les pertes de propagation.
Donc `PIRE = RSSI + L`.

## 3.1 Calculer le RSSI
Le **RSSI** tient compte du **SNR**, des **pertes de pointages**, du **G/T** et de la [constante de  Boltzmann](https://fr.wikipedia.org/wiki/Constante_de_Boltzmann). On va chacun les √©tudier s√©par√©ment.

### 3.1.1 SNR
Dans un premier temps, il nous faut calculer le `S/N` ou `SNR` qui mesure le rapport entre la puissance du **signal** et le **bruit**. 
![SNR](/images/blog/writeups/linky/linky3.svg)
C'est lui qui d√©termine la qualit√© du signal et on peut le calculer avec la formule `S/N = Eb/No * 10log(Rb/B)` ([lien formule](https://www.rfwireless-world.com/calculators/Eb-N0-and-BER-calculator.html)).
Le **BER** (**B**it **E**rror **R**ate) c'est le rapport de bits re√ßus avec des erreurs par rapport au nombre total de bits transmis. Par exemple :

![BER](/images/blog/writeups/linky/linky2.svg)
Le **Eb/No** quant √† lui permet de mesurer la qualit√© d'un **signal num√©rique**. C'est aussi un rapport mais entre l'√©nergie n√©cessaire √† envoy√© pour `1 bit` et le **bruit**. Donc plus le **Eb/No** est √©lev√©e, plus le **BER** diminue et plus la transmission est fiable.
- Le **Eb/No** pour le **BER**, on nous le donne, c'est `4.4dB`. D'apr√®s la question, on sait qu'on a une marge de `10dB` donc le **Eb/No** vaudra `14.4dB`.
- Pour le **d√©bit binaire**, pareil, on nous le donne, c'est `10000000.0bps` donc `10Mbps`.
- Aussi, il faut penser √† enlever d√®s maintenant les pertes de d√©modulation dues aux imperfections de l‚Äôimpl√©mentation de la d√©modulation. Elles nous sont donn√©es par `Receive Demodulator Implementation Loss (dB): -2`.

On peut √† pr√©sent faire le calcul :
```bash
>>> import np as np
>>> eb_no = 14.4 #dB
>>> bitrate = 10e6 #bps
>>> demodulator_loss = -2 #dB
>>> s_n = eb_no + 10 * np.log10(bitrate) - demodulator_loss #dB
>>> print(s_n)
86.4
```
Ce qui nous donne un `S/N` de `86.4dB`.

### 3.1.2 Pertes de pointage de l'antenne r√©ceptrice
Lorsque l‚Äôantenne n‚Äôest pas parfaitement align√©e avec la source du signal, une partie de l‚Äô√©nergie est perdue. Cette perte doit √™tre prise en compte pour ajuster le calcul de la puissance re√ßue. Ces pertes peuvent se calculer ainsi : `pertes de pointages = -12 * (erreur de pointage/largeur de faisceau)^2` ([lien formule](https://www.microwavejournal.com/articles/3371-antenna-selection-to-minimize-pointing-requirements)). 
Pour r√©cup√©rer la **largeur de faisceau** de la parabole r√©ceptrice ([beam width](https://en.wikipedia.org/wiki/Beam_diameter)) on aura besoin de  cette formule : `BW=(Œª/D)*70` avec `Œª` la longueur d'onde en `m` et `D` le diam√®tre de la parabole en `m` ([lien formule](https://www.calculatorultra.com/fr/tool/antenna-beamwidth-calculator.html?utm_source=chatgpt.com#gsc.tab=0)).
Enfin, on peut calculer les pertes de pointages :
```bash
>>> Œª = 0.025 #m
>>> d = 5.3 #m
>>> beamwidth = (Œª/d)*70 #m
>>> rx_pointing_error = 0.2
>>> rx_pointing_loss = -12*(rx_pointing_error/rx_beamwidth)**2 #dB
>>> print(rx_pointing_loss)
-4.402677551020408
```
Ce qui nous donne des pertes de pointage d'√† peu pr√®s `-4.4dB`.

### 3.1.3 Calcul final du RSSI
√Ä pr√©sent, on peut passer au calcul de notre **RSSI** d√©finit par `RSSI = s_n - pointing_loss + boltzmann - G/T` : 
```bash
>>> import np as np
>>> rx_pointing_loss = -4.4 #dB
>>> boltzmann_j_k = 1.38065e-23 # J/K
>>> boltzmann = 10*np.log10(boltzmann_j_k) #dBW_K
>>> rssi = s_n - rx_pointing_loss + boltzmann - g_t #dBW
>>> print(rssi)
-162.49580056501418
```
Notre **RSSI** vaut donc environ `-162.5dBW`.

## 3.2 Calculer les pertes de propagation
On a plusieurs pertes d√©j√† donn√©es, il faut juste calculer en plus les **pertes de parcours**. Elles repr√©sentent l'att√©nuation naturelle d'un signal lorsqu'il se propage due √† la dispersion de l'√©nergie sur une surface de plus en plus grande avec la distance.
La formule est la suivante : `Pertes de parcours = -20*log10(Œª/(4*œÄ*D)` avec `Œª` la longueur d'onde en `m` et `D` la distance du parcours en `m` ([lien formule](https://fr.wikipedia.org/wiki/√âquation_des_t√©l√©communications#Expression_logarithmique)). 
Calculons tout √ßa : 
```bash
>>> import np as np
>>> Œª = 0.025 #m
>>> d = 2831*1E3 #m
>>> path_loss = 20*np.log10(Œª/(4*np.pi*d)) #dB
>>> print(path_loss)
-183.06419449430322
```
Les pertes √† prendre en compte sont donc : 
```
Path Loss (dB) : -183 <- qu'on vient de calculer
Polarization Loss (dB): -0.5
Atmospheric Loss (dB): -2.1
Ionospheric Loss (dB): -0.1
Transmit Pointing Loss (dB): -1.74 <- √† ne pas confondre avec le Receive Poiting Loss qu'on a calcul√© plus t√¥t pour le RSSI
```

## 3.3 Calcul final de la PIRE
Rappellons la formule `PIRE = RSSI - toutes les pertes de propagation` et passons aux calculs : 
```bash
>>> polarization_loss = -0.5 #dB
>>> atmospheric_loss = -2.1 #dB
>>> ionospheric_loss = -0.1 #dB
>>> tx_pointing_loss = -1.74 #dB
>>> tx_eirp = rssi - path_loss - polarization_loss - atmospheric_loss - ionospheric_loss - tx_pointing_loss #dbW
>>> print(tx_eirp)
25.008393929289046
```
Super, notre **PIRE** vaut `25dBW`.

## 3.4 Calcul final du Transit Power
Allez, on y est presque, on rappelle que pour calculer la **puissance d'√©mission**, on doit appliquer cette formule : `P = PIRE + L - G`. `tx_line_loss` nous est donn√© √©gal √† `-1`. Sa valeur √©tant d√©j√† n√©gative puisque c'est une perte, il faut la soustraire dans notre formule au lieu de l'additioner. Elle devient donc `P = PIRE - L - G`. 
```bash
>>> tx_line_loss = -1 #dB
>>> tx_antenna_gain = 16.23 #dB
>>> transit_power_dbW = tx_eirp - tx_line_loss - tx_antenna_gain #dBW
>>> transit_power_W = 10**(transit_power_dbW/10) #W
>>> print(transit_power_W)
9.502533141159013
```

Entrons la valeur :
```bash
> docker run --rm -i -e FLAG=pouet linky:challenge
...
Determine the transmit power (in W) to achieve 10dB of Eb/No margin (above minimum for BER): 9.7

Winner Winner Chicken Dinner
...
You got it! Here's your flag:
pouet
```
Et √ßa marche, on obtient le flag ! 
Alors, oui, si vous observez bien, j'ai mis `9.7` alors que j'avais trouv√© `9.5`. En fait, cette valeur ne fonctionnait pas et je ne trouvais pas o√π √©tait l'erreur. J'ai donc essay√© des valeurs voisines et `9.7` a fonctionn√© üòÑ. 
En r√©alit√©, si on observe le code [source du challenge](https://github.com/cromulencellc/hackasat-qualifier-2021/blob/main/linky/challenge/challenge.py), on voit qu'en fonction de ce que l'on entre comme valeur, les r√©ponses peuvent √™tre diff√©rentes. Par exemple, la [solution officielle](https://github.com/cromulencellc/hackasat-qualifier-2021/blob/main/linky/solver/solver.py) utilise comme **gain** `54`, `24.8` comme **G/T** et `9.5` comme **transmit power**. Mais bref, on s'en fiche, l'essentiel, c'est d'avoir bien compris comment jouer avec toutes ces valeurs :) 